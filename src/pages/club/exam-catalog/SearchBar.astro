---
interface Props {
    formId?: string
    inputId?: string
    buttonId?: string
}

const {
    formId = 'searchForm',
    inputId = 'searchInput',
    buttonId = 'searchButton',
} = Astro.props
---

<form id={formId}>
    <label
        for={inputId}
        class="mb-2 text-sm font-medium text-gray-900 sr-only dark:text-white"
        >Search</label
    >
    <div class="relative min-w-[200px]">
        <div
            class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none"
        >
            <svg
                aria-hidden="true"
                class="w-5 h-5 text-gray-500 dark:text-gray-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
                ><path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg
            >
        </div>
        <input
            type="search"
            id={inputId}
            class="block w-full p-4 pl-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
            placeholder="z. B. Il-Jang"
            required
        />
        <button
            type="submit"
            id={buttonId}
            class="text-white absolute right-2.5 bottom-2.5 font-medium rounded-lg text-sm px-4 py-2 bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 disabled:bg-blue-400 disabled:dark:bg-blue-500 disabled:cursor-not-allowed"
            disabled>Suchen</button
        >
    </div>
</form>

<script>
    import Fuse from 'fuse.js'
    import Mousetrap from 'mousetrap'

    import { stripHtml } from '@components/utils'
    import { Content as ContentType } from './Content.astro'
    import { NormalizedSection } from './utils.astro'

    /** Definde in <script> in index.astro */
    declare global {
        var sections: NormalizedSection[]
    }

    type SearchableSection = Pick<NormalizedSection, 'id' | 'parentTitles'> & {
        stringified: string
    }
    type SearchResult = {
        id: string
        breadcrumbs: string[]
        preview: string
    }

    /** Doing this at build time doesn't work because using `jsdom` causes errors. */
    function stringifyContent(content: ContentType): string {
        if ('text' in content) {
            return content.text
        }
        if ('html' in content) {
            return stripHtml(content.html)
        }
        if ('enumerate' in content) {
            return content.enumerate
                .map((item) => stringifyContent(item))
                .join('\n- ')
        }
        if ('itemize' in content) {
            return content.itemize
                .map((item) => stringifyContent(item))
                .join('\n- ')
        }
        if ('table' in content) {
            return (
                content.table.head
                    ?.map((row) =>
                        row.map((cell) => stringifyContent(cell)).join(' '),
                    )
                    .join('\n') ??
                '' +
                    content.table.body
                        .map((row) =>
                            row.map((cell) => stringifyContent(cell)).join(' '),
                        )
                        .join('\n')
            )
        }
        return ''
    }

    function flattenedSections(
        nestedSections: NormalizedSection[],
    ): SearchableSection[] {
        const flatSections: SearchableSection[] = []
        nestedSections.forEach(
            ({ id, title, content, parentTitles, sections }) => {
                flatSections.push(
                    {
                        id,
                        parentTitles,
                        stringified:
                            title +
                                '\n\n' +
                                content
                                    ?.map((content) =>
                                        stringifyContent(content),
                                    )
                                    .join('\n\n') ?? '',
                    },
                    ...flattenedSections(sections),
                )
            },
        )
        return flatSections
    }
    const flatSections = flattenedSections(window.sections)
    console.log('flattenedSections', flatSections)

    const SEARCH_KEY = 'stringified'
    const MIN_MATCH_CHAR_LENGTH = 4
    const fuse = new Fuse(flatSections, {
        // isCaseSensitive: false,
        includeScore: true,
        // shouldSort: false,
        includeMatches: true,
        findAllMatches: true,
        minMatchCharLength: MIN_MATCH_CHAR_LENGTH,
        // location: 0,
        // threshold: 0.6,
        // distance: 2000,
        useExtendedSearch: true,
        ignoreLocation: true,
        // ignoreFieldNorm: true,
        // fieldNormWeight: 1,
        keys: [SEARCH_KEY],
    })

    function highlightMatches(
        value: string,
        indices: readonly [number, number][],
    ): string {
        let result = ''
        // const reversedIndices = [...indices].reverse()
        // let firstMatchStart: number
        let lastMatchEnd: number
        for (const [start, end] of indices) {
            if (result.length === 0) {
                result += value.slice(0, start)
            }
            if (lastMatchEnd) {
                result += value.slice(lastMatchEnd, start)
            }
            result += '<strong>' + value.slice(start, end + 1) + '</strong>'
            lastMatchEnd = end
        }
        result += value.slice(lastMatchEnd)
        return result
    }

    function search(query: string): SearchResult[] {
        // console.log(fuse.search(`="${query}"`))
        // console.log(fuse.search(`'"${query}"`))
        // console.log(fuse.search(query))
        const results: Fuse.FuseResult<SearchableSection>[] = fuse.search(
            `'"${query}"`,
        )
        console.log(results)
        return results.map(({ item, matches = [] }) => ({
            id: item.id,
            breadcrumbs: item.parentTitles,
            preview: highlightMatches(item[SEARCH_KEY], matches[0].indices),
        }))
    }

    // TODO: Use from Props
    const searchForm = document.querySelector('#searchForm') as HTMLFormElement
    const searchInput = searchForm.querySelector('input')
    const searchButton = searchForm.querySelector('button')
    searchInput.addEventListener('keydown', (event) => {
        searchButton.disabled =
            event.key === 'Backspace' ||
            searchInput.value.length < MIN_MATCH_CHAR_LENGTH - 1
    })
    searchForm.addEventListener('submit', (event) => {
        event.preventDefault()
        const searchQuery = searchInput.value
        const results = search(searchQuery)
        console.log(results)
    })

    Mousetrap.bind(['command+f', 'ctrl+f'], () => {
        console.log('command f or control f')
        searchInput.focus()
        return false // prevent default, stop bubbling
    })
</script>
