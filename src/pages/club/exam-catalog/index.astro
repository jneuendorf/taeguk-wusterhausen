---
import Layout from '@layouts/Layout.astro'
import RelImage from '@components/RelImage.astro'
import DownloadLink from '@components/links/DownloadLink.astro'
import { stripHtml, toId } from '@components/utils'

import Section, { Section as SectionType } from './Section.astro'
import Content, { Content as ContentType } from './Content.astro'
import { NormalizedSection, tabId } from './utils.astro'

function normalizedSection(
    section: SectionType,
    parents: SectionType[],
): NormalizedSection {
    if (section.parentTitles?.length > 0) {
        throw new Error('Section already has `parentTitles`')
    }
    return {
        content: [], // Make sure it's not `undefined`
        ...section,
        sections: (section.sections ?? []).map((subSection) =>
            normalizedSection(subSection, [...parents, section]),
        ),
        id: toId(section.title),
        parentTitles: parents.map((parent) => parent.title),
    }
}

const sections: NormalizedSection[] = (
    (await Astro.glob('./data/*.yml')) as SectionType[]
).map((section) => normalizedSection(section, []))
// console.log(sections[0].sections)
---

<Layout title="Prüfungskatalog" initFlowbite={false}>
    <div class="flex flex-wrap justify-between gap-4 md:gap-32 lg:gap-64">
        <div class="flex-none">
            <h1 class="inline">Prüfungskatalog</h1>
        </div>
        <div class="flex-grow">
            <form id="searchForm">
                <label
                    for="searchInput"
                    class="mb-2 text-sm font-medium text-gray-900 sr-only dark:text-white"
                    >Search</label
                >
                <div class="relative min-w-[200px]">
                    <div
                        class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none"
                    >
                        <svg
                            aria-hidden="true"
                            class="w-5 h-5 text-gray-500 dark:text-gray-400"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg"
                            ><path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            ></path></svg
                        >
                    </div>
                    <input
                        type="search"
                        id="searchInput"
                        class="block w-full p-4 pl-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                        placeholder="z. B. Il-Jang"
                        required
                    />
                    <button
                        type="submit"
                        id="searchButton"
                        class="text-white absolute right-2.5 bottom-2.5 font-medium rounded-lg text-sm px-4 py-2 bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 disabled:bg-blue-400 disabled:dark:bg-blue-500 disabled:cursor-not-allowed"
                        disabled>Suchen</button
                    >
                </div>
            </form>
        </div>
    </div>
    <p>
        <DownloadLink
            href="pdfs/pruefungskatalog.pdf"
            text="PDF herunterladen"
            download="Prüfungskatalog.pdf"
        />
    </p>
    <p>
        Anforderungen und Katalog stellen lediglich eine Empfehlung des
        Vorstandes in Absprache mit dem Landesprüfungsreferenten des TVBB dar.<br
        />
        Jede Prüfung setzt das Wissen der vorigen Grade voraus, d.&#8239;h. die Überprüfung
        des Vorprogramms ist bei jeder Prüfung implizit - insbesondere bisher erlernte
        Bewegungsformen.
    </p>
    <div class="border-b border-gray-200 dark:border-gray-700 not-prose">
        <ul
            class="flex flex-wrap -mb-px text-sm font-medium text-center"
            id="tabs"
            data-tabs-toggle="#tabContents"
            role="tablist"
        >
            {
                sections.map((section) => (
                    <li class="mr-2" role="presentation">
                        <button
                            class="inline-flex p-4 border-b-2 rounded-t-lg"
                            id={tabId(section)}
                            data-tabs-target={`#${section.id}`}
                            data-popover-target={`popover-${section.id}`}
                            type="button"
                            role="tab"
                            aria-controls={section.id}
                            aria-selected="false"
                        >
                            <svg
                                aria-hidden="true"
                                class="w-3 h-3 mt-1 mr-2"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="3"
                                viewBox="0 0 24 24"
                                xmlns="http://www.w3.org/2000/svg"
                            >
                                <clipPath id="cut-off">
                                    <rect x="12" y="0" width="12" height="24" />
                                </clipPath>
                                <circle
                                    cx="12"
                                    cy="12"
                                    r="11"
                                    fill={section.colors[0]}
                                />
                                <circle
                                    cx="12"
                                    cy="12"
                                    r="11"
                                    fill={section.colors[1]}
                                    clip-path="url(#cut-off)"
                                />
                            </svg>
                            {section.title}
                        </button>
                        {/* POPOVER */}
                        {section.icon && (
                            <div
                                data-popover
                                id={`popover-${section.id}`}
                                role="tooltip"
                                class="absolute z-10 invisible inline-block w-20 p-4 text-sm text-gray-500 transition-opacity duration-300 bg-white border border-gray-200 rounded-lg shadow-sm opacity-0 dark:text-gray-400 dark:border-gray-600 dark:bg-gray-800"
                            >
                                <RelImage
                                    src={section.icon}
                                    class="w-12 mx-auto"
                                />
                                <div data-popper-arrow />
                            </div>
                        )}
                    </li>
                ))
            }
        </ul>
    </div>
    <div id="tabContents">
        {
            sections.map((section) => (
                <div
                    class="hidden relative p-4 shadow-sm rounded-lg rounded-t-none bg-gray-50 dark:bg-gray-800"
                    id={section.id}
                    role="tabpanel"
                    aria-labelledby={tabId(section)}
                >
                    <>
                        {section.content?.map((content) => (
                            <Content content={content} />
                        ))}
                    </>
                    <div
                        class="max-w-screen-lg prose prose-table:w-full hover:prose-tr:bg-slate-100"
                        data-accordion="collapse"
                    >
                        {section.sections?.map((subSection, index) => (
                            <Section
                                {...subSection}
                                isFirst={index === 0}
                                isLast={index === section.sections.length - 1}
                                parentTitles={[section.title]}
                            />
                        ))}
                    </div>
                </div>
            ))
        }
    </div>
</Layout>

<script define:vars={{ sections }}>
    window.sections = sections
</script>

<script>
    import { initTabs } from 'flowbite/lib/esm/components/tabs'
    import { initPopovers } from 'flowbite/lib/esm/components/popover'
    import Accordion from 'flowbite/lib/esm/components/accordion'
    import { AccordionItem } from 'flowbite/lib/esm/components/accordion/types'
    import Fuse from 'fuse.js'
    import Mousetrap from 'mousetrap'

    import { BODY_PREFIX, ID_SEPARATOR, stripHtml } from '@components/utils'
    import { Content as ContentType } from './Content.astro'

    import { NormalizedSection } from './utils.astro'

    /** See script above */
    declare global {
        var sections: NormalizedSection[]
    }

    initTabs()
    initPopovers()

    /** Avoid scroll jumping because the hash coincidentally matches an element id. */
    const HASH_PREFIX = '_'

    let itemIds: string[] = []
    // Avoid invalid location hashes to cause errors (i.e. when entered by the user)
    if (window.location.hash.startsWith(`#${HASH_PREFIX}`)) {
        // Strip '#_'
        const activeElementId = window.location.hash.slice(
            1 + HASH_PREFIX.length,
        )
        const [tab, ...items] = activeElementId.split(ID_SEPARATOR)
        const activeTabId = `#${tab}-tab`
        itemIds = items.map(
            (_, index) =>
                `#${BODY_PREFIX}${tab}${ID_SEPARATOR}${items
                    .slice(0, index + 1)
                    .join(ID_SEPARATOR)}`,
        )

        // --------------------------------------------------------------------
        // Tabs
        if (activeElementId) {
            document.querySelector(activeTabId).dispatchEvent(
                new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true,
                }),
            )
        }
    }

    document.querySelectorAll('[data-tabs-target]').forEach((tabButton) => {
        tabButton.addEventListener('click', () => {
            const idSelector = tabButton.getAttribute('data-tabs-target')
            window.location.hash = `#${HASH_PREFIX}${idSelector.slice(1)}`
        })
    })

    // ------------------------------------------------------------------------
    // Accordion
    document
        .querySelectorAll('[data-accordion]')
        .forEach(function ($accordionEl) {
            var alwaysOpen = $accordionEl.getAttribute('data-accordion')
            var activeClasses = $accordionEl.getAttribute('data-active-classes')
            var inactiveClasses = $accordionEl.getAttribute(
                'data-inactive-classes',
            )
            const targetCandidates = [
                ...$accordionEl.querySelectorAll('[data-accordion-target]'),
            ] as HTMLElement[]
            // Group items by closest accordion parent to make nested accordions work.
            const items = targetCandidates
                .filter(
                    ($triggerEl) =>
                        $triggerEl.closest('[data-accordion]') === $accordionEl,
                )
                .map(($triggerEl) => ({
                    id: $triggerEl.getAttribute('data-accordion-target'),
                    triggerEl: $triggerEl,
                    targetEl: document.querySelector(
                        $triggerEl.getAttribute('data-accordion-target'),
                    ),
                    iconEl: $triggerEl.querySelector('[data-accordion-icon]'),
                    active:
                        $triggerEl.getAttribute('aria-expanded') === 'true'
                            ? true
                            : itemIds.includes(
                                  $triggerEl.getAttribute(
                                      'data-accordion-target',
                                  ),
                              ),
                })) as AccordionItem[]

            new Accordion(items, {
                alwaysOpen: alwaysOpen === 'open' ? true : false,
                activeClasses: activeClasses
                    ? activeClasses
                    : 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white',
                inactiveClasses: inactiveClasses
                    ? inactiveClasses
                    : 'text-gray-500 dark:text-gray-400',
                onOpen: (accordion, item) => {
                    // console.log('opened', item.id)
                    const semanticId = item.id.replace(BODY_PREFIX, '')
                    // console.log(semanticId)
                    window.location.hash = `#${HASH_PREFIX}${semanticId.slice(
                        1,
                    )}`
                },
            })
        })

    // ------------------------------------------------------------------------
    // Search
    type SearchableSection = Pick<NormalizedSection, 'id' | 'parentTitles'> & {
        stringified: string
    }
    type SearchResult = {
        id: string
        breadcrumbs: string[]
        preview: string
    }

    /** Doing this at build time doesn't work because using `jsdom` causes errors. */
    function stringifyContent(content: ContentType): string {
        if ('text' in content) {
            return content.text
        }
        if ('html' in content) {
            return stripHtml(content.html)
        }
        if ('enumerate' in content) {
            return content.enumerate
                .map((item) => stringifyContent(item))
                .join('\n- ')
        }
        if ('itemize' in content) {
            return content.itemize
                .map((item) => stringifyContent(item))
                .join('\n- ')
        }
        if ('table' in content) {
            return (
                content.table.head
                    ?.map((row) =>
                        row.map((cell) => stringifyContent(cell)).join(' '),
                    )
                    .join('\n') ??
                '' +
                    content.table.body
                        .map((row) =>
                            row.map((cell) => stringifyContent(cell)).join(' '),
                        )
                        .join('\n')
            )
        }
        return ''
    }

    function flattenedSections(
        nestedSections: NormalizedSection[],
    ): SearchableSection[] {
        const flatSections: SearchableSection[] = []
        nestedSections.forEach(
            ({ id, title, content, parentTitles, sections }) => {
                flatSections.push(
                    {
                        id,
                        parentTitles,
                        stringified:
                            title +
                                '\n\n' +
                                content
                                    ?.map((content) =>
                                        stringifyContent(content),
                                    )
                                    .join('\n\n') ?? '',
                    },
                    ...flattenedSections(sections),
                )
            },
        )
        return flatSections
    }
    const flatSections = flattenedSections(window.sections)
    console.log('flattenedSections', flatSections)

    const SEARCH_KEY = 'stringified'
    const MIN_MATCH_CHAR_LENGTH = 4
    const fuse = new Fuse(flatSections, {
        // isCaseSensitive: false,
        includeScore: true,
        // shouldSort: false,
        includeMatches: true,
        findAllMatches: true,
        minMatchCharLength: MIN_MATCH_CHAR_LENGTH,
        // location: 0,
        // threshold: 0.6,
        // distance: 2000,
        useExtendedSearch: true,
        ignoreLocation: true,
        // ignoreFieldNorm: true,
        // fieldNormWeight: 1,
        keys: [SEARCH_KEY],
    })

    function highlightMatches(value: string, indices: readonly [number, number][]): string {
        let result = ''
        // const reversedIndices = [...indices].reverse()
        // let firstMatchStart: number
        let lastMatchEnd: number
        for (const [start, end] of indices) {
            if (result.length === 0) {
                result += value.slice(0, start)
            }
            if (lastMatchEnd) {
                result += value.slice(lastMatchEnd, start)
            }
            result += (
                '<strong>'
                + value.slice(start, end + 1)
                + '</strong>'
            )
            lastMatchEnd = end
        }
        result += value.slice(lastMatchEnd)
        return result
    }

    function search(query: string): SearchResult[] {
        // console.log(fuse.search(`="${query}"`))
        // console.log(fuse.search(`'"${query}"`))
        // console.log(fuse.search(query))
        const results: Fuse.FuseResult<SearchableSection>[] = fuse.search(`'"${query}"`)
        console.log(results)
        return results.map(({item, matches = []}) => ({
            id: item.id,
            breadcrumbs: item.parentTitles,
            preview: highlightMatches(item[SEARCH_KEY], matches[0].indices),
        }))
    }

    const searchForm = document.querySelector('#searchForm') as HTMLFormElement
    const searchInput = searchForm.querySelector('input')
    const searchButton = searchForm.querySelector('button')
    searchInput.addEventListener('keydown', (event) => {
        searchButton.disabled =
            event.key === 'Backspace' ||
            searchInput.value.length < MIN_MATCH_CHAR_LENGTH - 1
    })
    searchForm.addEventListener('submit', (event) => {
        event.preventDefault()
        const searchQuery = searchInput.value
        const results = search(searchQuery)
        console.log(results)
    })

    Mousetrap.bind(['command+f', 'ctrl+f'], () => {
        console.log('command f or control f')
        searchInput.focus()
        return false // prevent default, stop bubbling
    })
</script>
